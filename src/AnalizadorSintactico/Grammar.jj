// Grammar.jj - Documentación en español
//
// Propósito:
// - Analizador sintáctico (JavaCC) para una versión reducida de Go (Golang).
// - Reconoce: package/import, declaraciones de tipos, structs simples, funciones,
//   variables (var / asignación corta), expresiones aritméticas y lógicas básicas,
//   if/for simples, print con fmt.Println/Print y return.
//
// Alcance y limitaciones:
// - Gramática simplificada: no cubre toda la semántica de Go (por ejemplo: interfaces,
//   métodos, canales, concurrencia, declaraciones complejas de mapas/slices, types avanzados).
// - Manejo de comentarios (//, /* */) está implementado en SKIP.
// - Las expresiones y operadores son básicas; puede haber ambigüedades para casos complejos.
// - Los literales de cadena y números están contemplados de forma básica.
//
// Cómo usar:
// - Generar el parser con JavaCC a partir de este fichero.
// - El punto de entrada del parser es la producción Start().
//
// Ejemplo mínimo de código Go que acepta la gramática:
//   package main
//   import "fmt"
//   func main() {
//     fmt.Println("Hola")
//   }

options {
    IGNORE_CASE = true;
    STATIC = false;
    BUILD_PARSER = true;
}

PARSER_BEGIN(GolangParser)

package AnalizadorSintactico;
public class GolangParser { }

PARSER_END(GolangParser)

// Sección: SKIP
// Comentarios y espacios en blanco se eliminan aquí. Mantener si se quiere permitir comentarios en el código fuente.
SKIP : {
    " "
  | "\t"
  | "\r"
  | "\n"
  |  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
  |  <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

// Sección: Palabras reservadas (tokens clave del lenguaje simplificado)
TOKEN : { 
    < IMPORT : "import" >
|   < PACKAGE : "package" >
|   < FUNC : "func" >
|   < VAR : "var" >
|   < CONST : "const" >
|   < TYPE : "type" >
|   < STRUCT : "struct" >
|   < MAP : "map" >
|   < SLICE : "slice" >
|   < RANGE : "range" >
|   < FOR : "for" >
|   < IF : "if" >
|   < ELSE : "else" >
|   < SWITCH : "switch" >
|   < CASE : "case" >
|   < DEF : "default" >
|   < RETURN : "return" >
|   <FMT : "fmt">
|   <PRINTLN : "Println">
|   <PRINT : "Print">
}

// Sección: Operadores
TOKEN : {
    < DOT : "." >
|   < PLUS : "+" >
|   < MINUS : "-" >
|   < MULTIPLY : "*" >
|   < DIVIDE : "/" >
|   < MOD : "%" >
|   < XOR : "^" >
|   < EQUAL : "==" >
|   < ASSIGN : "=" >
|   < NOT_EQUAL : "!=" >
|   < COLON : ":" >
|   < COLON_ASSIGN : ":=" >
|   < LT : "<" >
|   < GT : ">" >
|   < GTE : ">=" >
|   < LTE : "<=" >
|   < AND : "&&" >
|   < OR : "||" >
|   < NOT : "!" >
}

// Sección: Delimitadores (paréntesis, llaves, corchetes, comas, punto y coma)
TOKEN : {
    < LPAREN : "(" >
|   < RPAREN : ")" >
|   < LBRACE : "{" >
|   < RBRACE : "}" >
|   < LBRACKET : "[" >
|   < RBRACKET : "]" >
|   < COMMA : "," >
|   < SEMICOLON : ";" >
}

// Sección: Identificadores y literales
// - IDENTIFIER: nombres de variables, funciones, tipos.
// - INTEGER, FLOAT y STRING: literales numéricas y cadenas (implementación básica).
TOKEN : { 
    < IDENTIFIER : (["a"-"z", "A"-"Z", "_"]) (["a"-"z", "A"-"Z", "0"-"9", "_"])* >
|   < INTEGER : (["0"-"9"])+ >
|   < FLOAT : (["0"-"9"])+ "." (["0"-"9"])* >
|   < STRING : 
          "\"" ( ~["\"","\\","\n","\r"] 
        | "\\" ( ["n","t","b","r","f","\\","\'","\""] 
        | ["0"-"7"] (["0"-"7"])?  
        | ["0"-"3"] ["0"-"7"] ["0"-"7"] 
        | ( ["\n","\r"] 
        | "\r\n")))* "\""
    >
}

// Inicio de la gramática
// Punto de entrada: Start()
// - Valida package, imports y cero o más declaraciones a nivel superior.
void Start() : {}
{
    PackageClause() ImportDecl() (TopLevelDeclaration())* <EOF>
}

void PackageClause() : {}
{
    <PACKAGE> Identifier()
}

void ImportDecl() : {}
{
    <IMPORT> ("("ImportSpec() ( <SEMICOLON> ImportSpec() )* ")")?
}

void ImportSpec() : {}
{
    <STRING>
|   Identifier() <STRING>
}

// Declaraciones a nivel superior
void TopLevelDeclaration() : {}
{
    FunctionDecl()
|   TypeDecl()
|   VarStatement()
}

// Declaración de funciones
void FunctionDecl() : {}
{
    <FUNC> Identifier() Signature() Block()
}

void Signature() : {}
{
    Parameters() ( Result() )?
}

void Parameters() : {}
{
    <LPAREN> ( ParameterList() )? <RPAREN>
}

void ParameterList() : {}
{
    ParameterDecl() ( <COMMA> ParameterDecl() )*
}

void ParameterDecl() : {}
{
    Identifier() Type()
}

void Result() : {}
{
    Parameters()
|   Type()
}

// Declaración de tipos
void TypeDecl() : {}
{
    <TYPE> Identifier() Type()
}

void Type() : {}
{
    <STRUCT> <LBRACE> (FieldDecl())* <RBRACE>
|   <IDENTIFIER>
}

void FieldDecl() : {}
{
    Identifier() Type()
}

// Bloques y declaraciones de variables
void Block() : {}
{
    <LBRACE> (Statement())* <RBRACE>
}

void Statement() : {}
{
    VarStatement()
|   ExpressionStatement()
|   ReturnStatement()
|   Block()
|   IfStatement()
|   ForStatement()
|   Print()
}

void Print() : {}
{
<FMT> <DOT> (<PRINT> | <PRINTLN>) "(" (Expression() (<COMMA> Expression())*)? ")"
}

void VarStatement() : {}
{
    VarDeclaration()
|   (IdentifierList() (ShortDeclaration() | Assignment()))

}

void VarDeclaration() : {}
{
    <VAR> IdentifierList() ( (<ASSIGN> ExpressionList()) | Multiple())?
}

void Multiple() : {}
{
    Expression() (<ASSIGN> Expression() (<COMMA> Expression())*)?
}

void ShortDeclaration() : {}
{
    <COLON_ASSIGN> ExpressionList()
}

void Assignment() : {}
{
    <ASSIGN> ExpressionList() 
}

void ExpressionStatement() : {}
{
    Expression()
}

void ReturnStatement() : {}
{
    <RETURN> (Operation())?
}

void Operation() : {}
{
    Expression() (Operator() Expression())*
}

void IfStatement() : {}
{
    <IF> condicion() ( op_logic() condicion() )* Block() ( <ELSE> Block() )?
}

void condicion(): {}
{
    condicionS() (op_logic() condicionS())*
}

void condicionS(): {}
{
    Expression() op_relation() Expression()
}

void op_logic(): {}
{
      <AND>
    | <OR>
    | <NOT>
}

void op_relation(): {}
{
      <NOT_EQUAL>
    | <LT>
    | <LTE>
    | <EQUAL>
    | <GT>
    | <GTE>
    | <NOT>
}

void ForStatement() : {}
{
    <FOR> condicionS() Block() | (IdentifierList() (ShortDeclaration() | Assignment()) <SEMICOLON> condicionS() <SEMICOLON> STEP() Block()) 
}

void STEP() : {}
{
    <IDENTIFIER> ("++" | "--")
}

// Listas de identificadores y expresiones
void IdentifierList() : {}
{
    Identifier() ( <COMMA> Identifier() )*
}

void Identifier() : {}
{
    <IDENTIFIER>
}

void ExpressionList() : {}
{
    Expression() ( <COMMA> Expression() )* 
}

void Expression() : {}
{
    <INTEGER>
|   <FLOAT>
|   ( <IDENTIFIER> (Exxxpresion())? )
|   <STRING>
}

void Exxxpresion() : {}
{
    "(" (Expression() (OList() | EList()))? ")"
}

void EList() : {}
{
    ( <COMMA> Expression() ) *
}

void OList() : {}
{
    (Operator() Expression())*
}

void Operator() : {}
{
    <PLUS>
    | <MINUS>
    | <MULTIPLY>
    | <DIVIDE>
    | <MOD>
}
